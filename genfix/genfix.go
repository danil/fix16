// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// package genfix is a XML specification parser and FIX message format generator.
package genfix

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"go/format"
	"log"
	"os"
	"path"
	"strings"
	"text/template"
	"time"

	"github.com/danil/protofix/specfix"
	"github.com/danil/protofix/stringfix"
)

//go:generate go run main.go

type pkgInf struct {
	pkg  string
	desc string
}

var specs = map[pkgInf][]byte{
	pkgInf{pkg: "moex44", desc: "MOEX.4.4 (FIX.4.4)"}: specfix.MOEX44,
}

func Generate(dir string) error {
	for inf, src := range specs {
		pth := path.Join(dir, inf.pkg)
		fmt.Printf("Generating %s ...", pth)

		err := pkgGen{inf: inf, dir: pth}.generate(src)
		if err != nil {
			return fmt.Errorf("generate package: %q, directory: %q, %w", inf.pkg, pth, err)
		}

		fmt.Println("ok")
	}

	return nil
}

type pkgGen struct {
	inf pkgInf
	dir string
}

type fldDef struct {
	Name string
	Tag  int
}

type tplMsg struct {
	Name   string
	Fields []tplFld
}

type tplFld struct {
	Name     string
	Required bool
	Def      fldDef
}

func (g pkgGen) generate(src []byte) error {
	var spec xmlSpec
	r := bytes.NewReader(src)
	d := xml.NewDecoder(r)

	err := d.Decode(&spec)
	if err != nil {
		return fmt.Errorf("xml decoder: decode: %w", err)
	}

	defs := make([]fldDef, 0, len(spec.Fields))
	defByName := make(map[string]fldDef, len(spec.Fields))

	for _, f := range spec.Fields {
		d := fldDef{Name: f.Name, Tag: f.Number}
		defs = append(defs, d)
		defByName[f.Name] = d
	}

	var b bytes.Buffer

	err = constTmpl.Execute(&b, struct {
		Package    string
		FormatDesc string
		Year       int
		Fields     []fldDef
	}{
		Package:    g.inf.pkg,
		FormatDesc: g.inf.desc,
		Year:       time.Now().Year(),
		Fields:     defs,
	})
	if err != nil {
		return fmt.Errorf("text template execute: %w", err)
	}

	if _, err := os.Stat(g.dir); os.IsNotExist(err) {
		err = os.Mkdir(g.dir, os.ModeDir|0755)
		if err != nil {
			return fmt.Errorf("os: make directory: %w", err)
		}
	}

	fname := fmt.Sprintf("%s_format.go", g.inf.pkg)
	pth := path.Join(g.dir, fname)
	f, err := os.Create(pth)
	if err != nil {
		return fmt.Errorf("os: create file %q: %w", pth, err)
	}
	defer f.Close()

	p, err := format.Source(b.Bytes())
	if err != nil {
		return fmt.Errorf("go format source: %w", err)
	}

	_, err = f.Write(p)
	if err != nil {
		return fmt.Errorf("os file write %q: %w", pth, err)
	}

	for _, msg := range spec.Messages {
		m := tplMsg{Name: msg.Name}
		flds := make([]tplFld, 0, len(msg.Fields))

		for _, fld := range msg.Fields {
			d, ok := defByName[fld.Name]
			if !ok {
				log.Printf("missing field %q definition", fld.Name)
			}
			f := tplFld{Name: fld.Name, Required: fld.Required, Def: d}
			flds = append(flds, f)
		}

		m.Fields = flds

		err = msgGen{msg: m, inf: g.inf, dir: g.dir}.generate(src)
		if err != nil {
			return fmt.Errorf("generate message: %q package: %q, directory: %q, %w", msg.Name, g.inf.pkg, g.dir, err)
		}
	}

	return nil
}

type msgGen struct {
	msg tplMsg
	inf pkgInf
	dir string
}

func (g msgGen) generate(src []byte) error {
	var b bytes.Buffer

	err := msgTmpl.Execute(&b, struct {
		Package    string
		Format     string
		FormatDesc string
		Year       int
		Message    string
		Fields     []tplFld
	}{
		Package:    g.inf.pkg,
		Format:     strings.ToUpper(g.inf.pkg),
		FormatDesc: g.inf.desc,
		Year:       time.Now().Year(),
		Message:    g.msg.Name,
		Fields:     g.msg.Fields,
	})
	if err != nil {
		return fmt.Errorf("text template execute: %w", err)
	}

	fname := fmt.Sprintf("%s_%s_format.go", g.inf.pkg, stringfix.ToSnakeCase(g.msg.Name))
	pth := path.Join(g.dir, fname)
	f, err := os.Create(pth)
	if err != nil {
		return fmt.Errorf("os: create file %q: %w", pth, err)
	}
	defer f.Close()

	p, err := format.Source(b.Bytes())
	if err != nil {
		return fmt.Errorf("go format source: %w", err)
	}

	_, err = f.Write(p)
	if err != nil {
		return fmt.Errorf("os file write %q: %w", pth, err)
	}
	return nil
}

var constTmpl = template.Must(template.New("").Parse(`// Code generated by protofix; DO NOT EDIT.
// Copyright {{ .Year }} The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package {{ .Package }} provides {{ .FormatDesc }} protocol format.
package {{ .Package }}

const Req, Opt = true, false

const (
{{- range .Fields }}
	{{ .Name }}{{ .Tag }} = {{ .Tag }}
{{- end }}
)
`))

var msgTmpl = template.Must(template.New("").Parse(`// Code generated by protofix; DO NOT EDIT.
// Copyright {{ .Year }} The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package {{ .Package }} provides {{ .FormatDesc }} protocol format.
package {{ .Package }}

import (
	f0 "github.com/danil/protofix/codecfix"
	"github.com/danil/protofix/marshfix"
)

var (
	{{ .Format }}{{ .Message }}Marshaler   = marshfix.Marshal{Tag: "{{ .Format }}", Format: {{ .Format }}{{ .Message }}}
	{{ .Format }}{{ .Message }}Unmarshaler = marshfix.Unmarshal{Tag: "{{ .Format }}", Format: {{ .Format }}{{ .Message }}}
)

// {{ .Format }}{{ .Message }} is a {{ .FormatDesc }} format of the {{ .Message }} message which maps the codecs into individual fields.
var {{ .Format }}{{ .Message }} = f0.Format{
	Fields: map[int]f0.Codec{
	},
	BodyLength9:	f0.BodyLengthFld{},
	CheckSum10:		f0.ChecksumStringFld{},
	Unknown:			f0.UnknownFld{},
	Sort: []int{
	{{- range .Fields }}
		{{ .Name }}{{ .Def.Tag }},
	{{- end }}
	},
}
`))
